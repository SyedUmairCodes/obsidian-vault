Welcome to Lesson 3 of Module 5 an extended query formulation with SQL. I'm going to start with an important motivational question. Why are join operations and grouping a powerful combination, especially for business intelligence processing?
Play video starting at ::27 and follow transcript0:27
Lesson 2 provided more realistic problems involving multiple tables.This lesson has grouping requirements, in addition to the requirement of multiple tables. The objectives in this lesson involve more complex problems. First, you should use the critical questions to analyze more complex problem statements with requirements for both multiple tables and row summaries. As you gain confidence with more difficult problems, you should be able to use the critical questions implicitly while writing select statements. Second, you should apply an extended Statement pattern to write select statements for more complex problems with multiple joins and grouping clauses.
Play video starting at :1:11 and follow transcript1:11
You should be very familiar with a university database diagram from past lessons. The examples in this lesson involve three, four, and five tables connected by relationships. After identifying required tables for a problem, you should use the university database diagram to understand the connections. For example, to combine the course and student tables, you need to use the offering enrollment tables is of course in student tables are not directly connected. The grouping statement pattern for the cross-product join style extends the patterns shown in Lesson 2. The extended statement pattern still shows end tables in the from clause and minus 1 join conditions in the where clause. The extended pattern as aggregate functions in the select clause have the columnist without aggregate functions, the group by clause contains a same column list as a select clause. Each condition in the optional having clause must contain an aggregate function. A similar extension can be made for the join operator pattern shown in Lesson 2. Now, let's use the critical questions on example 1, answering the questions before reviewing the associated select statement. What tables? The enrollment table is needed because the result includes the count of students enrolled. The offering table is needed because of the condition we`re offering here. The student table is needed because the result contains the average GPA. How are the tables combined? The offering enrollment tables must be joining an OfferNo, using a condition with the primary foreign key at the tables. The enrollment student tables must be joined in StdNo using a condition with a primary key, foreign key and the tables. Individual rows versus groups rows. Groups rows are needed because the result contains the average GPA and a condition involves average GPA. The select statement shows three columns and result, including two computed columns using the count and AVG functions. Note renaming a result column with the AS clause to ensure meaningful column names in the result table. The from clause uses the cross-product style to combine student enrollment and offering tables. The where clause is to join conditions and a condition on offering year. The group by clause includes the offer no column. The having clause includes a condition using the AVG function. See the Module 5 examples for an equivalent statement using the join operator style. Let's use the critical questions on Example 2, answering the questions before reviewing the Associate select statement. What tables? The offering table is needed because of conditions and offering year term as well as columns in a result, course number and offer number. The enrollment table is needed because of the count of students enrolled is in the result. The course table is not needed because CourseNo can be taken from the offering table and offering that CourseNo, does not have values. The student table is not needed because no columns are used. The enrollment table can be used to compute the count of students enrolled as each enrollment row is associated to a student row.
Play video starting at :4:41 and follow transcript4:41
How are tables combined? The offering enrollment tables must be joining an offer, no, using the condition with a primary key, foreign key of the tables, individual rows versus groups rows. groups rows are needed because the result includes the count of students enrolled computed using the count function. The select statement shows three columns in the result, including an aggregate computation using the count function. Note renaming with the as clause to ensure meaningful column name and the result table. The from clause uses the cross-products joint style to combine the enrollment and offering tables. The where clause is one joint condition and conditions on offering year-end term. See the Module 5 examples for an equivalent statement using the join operator style. The group by clause includes the offer number and course number columns. Both columns must be included in a groupby clause as they're used in the select clause. Every column in the select clause must be in a group by clause, except for columns used in aggregate function calculations. Now, let's use the critical questions on Example 3, answering the questions before reviewing the associated select statement. Example 3 involves more tables in previous examples in this lesson. What tables? The offering table supports conditions and offering enrollment term. The student table provides the average GPA and the result. The faculty table provides a faculty name columns and the result. The enrollment table connects the offering and student tables. The course table is not needed because the offering table contains the CourseNo column, and the offering that course number column does not have values. How are the tables combined? The faculty and offering tables must be joined on FacNo, using a primary key, foreign key condition. The offering enrollment tables must be joined an OfferNo. Using a condition with a primary key, foreign key of the tables. The enrollment and student tables must be joined on StdNo, using a condition with a primary key, foreign key of the tables.
Play video starting at :7:2 and follow transcript7:02
Individual rows versus groups rows. groups rows are needed because the result and close average GPA and a condition involves average GPA.
Play video starting at :7:14 and follow transcript7:14
The select statement shows five columns and result, including an aggregate computation using the AVG function. Not renaming with the AS clause to ensure meaningful column names in the result table. The from clause uses the cross-product join style to combine the four tables. The where clause is three joint conditions and conditions and offering in term. See the Module 5 examples for an equivalent statement using the join operator style.
Play video starting at :7:48 and follow transcript7:48
The group by clause includes the OfferNo, CourseNo, FacFirstName and FacLastName columns. All columns must be included in the group by clause as they are used in the select clause. Every column in the select clause must be in a group by clause, except for columns use in aggregate function calculations. The having clause contains a condition using the AVG function.
Play video starting at :8:17 and follow transcript8:17
Let's wrap up Lesson 3 about problems involving multiple tables in grouping. The lesson emphasized analysis of problem statements using the critical questions, and formulation of select statements using an extended statement pattern with a grouping clause. Examples demonstrated grouping with three and four tables, as well as grouping on multiple columns. An answer to the opening question. Joins and grouping commonly support business intelligence. As you will see in Course 2, data warehouses use a table design pattern that requires joint operations combined with grouping and most queries. Course 3 provides many examples of these types of queries, along with select statement extensions to support business intelligence applications.